import { Router, Request, Response } from "express";
import { db } from "../storage";
import { organizations, processes, processSteps, users, userOrganizations, organizationModules } from "../../shared/schema";
import { eq, and, inArray } from "drizzle-orm";
import { supabaseAdmin } from "../supabase";
import { industryTemplates } from "../seed";

// Need to duplicate logic since we can't import client-side code directly in Node if it uses React types
// For now, we'll trust the client sends the nodes, OR we re-generate here.
// Best practice: Trust client for the *Edited* nodes, since user might have changed them.

const router = Router();

async function getOrgId(req: Request): Promise<string | null> {
    const authHeader = req.headers.authorization;
    if (!authHeader) return null;
    const token = authHeader.replace("Bearer ", "");
    const { data: { user }, error } = await supabaseAdmin.auth.getUser(token);
    if (error || !user) return null;
    const userOrg = await db.query.userOrganizations.findFirst({ where: eq(userOrganizations.userId, user.id) });
    return userOrg ? userOrg.organizationId : null;
}

router.post("/complete", async (req: Request, res: Response) => {
    try {
        const organizationId = await getOrgId(req);
        if (!organizationId) return res.status(401).json({ message: "Unauthorized" });

        const { nodes, edges, industry: selectedIndustry } = req.body;

        // Fetch organization to get industry
        const org = await db.query.organizations.findFirst({
            where: eq(organizations.id, organizationId)
        });

        if (!org) return res.status(404).json({ message: "Organization not found" });

        const industry = org.industry; // Use the industry from signup

        // 1. Update Organization Profile - mark onboarding as completed
        const finalIndustry = selectedIndustry || org.industry;

        await db.update(organizations)
            .set({
                industry: finalIndustry as any,
                onboardingStatus: 'completed',
                meta: {
                    ...(org.meta as object || {}),
                    onboarding_completed_at: new Date().toISOString(),
                    workflow_customized: nodes && nodes.length > 0,
                    selected_industry: finalIndustry
                }
            })
            .where(eq(organizations.id, organizationId));

        // 2. Enable modules based on industry template if not already enabled
        const templateModules = industryTemplates[finalIndustry as keyof typeof industryTemplates] || industryTemplates.other;

        // Get already enabled modules
        const existingModules = await db.query.organizationModules.findMany({
            where: eq(organizationModules.organizationId, organizationId)
        });
        const existingModuleIds = existingModules.map(m => m.moduleId);

        for (const moduleId of templateModules) {
            if (!existingModuleIds.includes(moduleId)) {
                await db.insert(organizationModules).values({
                    organizationId,
                    moduleId,
                    enabled: true,
                });
            }
        }

        // 2. Create the Main Process
        const [proc] = await db.insert(processes).values({
            organizationId,
            name: `Proceso Principal - ${industry}`,
            type: 'production', // Generic for now
            description: `Generated by Nexus Architect for ${industry}`,
            isTemplate: false,
            workflowData: { nodes, edges } // Store the complete workflow
        }).returning();

        // 3. Create Steps from Nodes
        // We assume 'nodes' is an array of ReactFlow nodes
        if (nodes && Array.isArray(nodes)) {
            // Sort by Y position to roughly determine order
            const sortedNodes = nodes.sort((a: any, b: any) => a.position.y - b.position.y);

            for (let i = 0; i < sortedNodes.length; i++) {
                const node = sortedNodes[i];
                await db.insert(processSteps).values({
                    processId: proc.id,
                    name: node.data.label || node.data.name || 'Untitled Step',
                    type: node.type === 'input' ? 'task' : node.type === 'output' ? 'milestone' : 'task',
                    order: i + 1,
                    expectedDuration: 60, // Default 1 hour (in minutes)
                    dependencies: [], // Complex edge mapping omitted for MVP
                    criticalKpis: {} // Empty KPIs object
                });
            }
        }

        res.json({ success: true, message: "Onboarding completed", processId: proc.id, industry });

    } catch (error) {
        console.error("Onboarding error:", error);
        res.status(500).json({ message: "Internal server error" });
    }
});

export const onboardingRoutes = router;
